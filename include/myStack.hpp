#pragma once

#include <iostream>
#include <stdlib.h>


namespace handMadeStack
{

	template <typename Data_t>
	class myStack
	{
	public:

		myStack();

		myStack(size_t size);

		// Copy/move constructor
		myStack(const myStack& stack);
        myStack(myStack&& stack);

        // Copy/move assignment:
        myStack& operator=(const myStack& Stack);
        myStack& operator=(myStack&& Stack);

        // Destructor:
        ~myStack();

        size_t size() const;
        size_t capacity() const;
        myStack& resize(size_t size);


        void push(const Data_t& element);
        void push(Data_t&& element);
        
        void pop();

        Data_t& top() const;

        bool empty() const;

        bool operator==(const myStack& other) const;
        bool operator!=(const myStack& other) const;

        bool good() const;

	private:

		Data_t* data_;
		size_t size_;
		size_t capacity_;


	} // class myStack


	template <typename Data_t>
	myStack<Data_t>::myStack():
        data_ (nullptr),
        size_ (0),
        capacity_ (0)
	{
		CHECK(this->good(), "Unable to construct stack\n");
	}


	template <typename Data_t>
	myStack<Data_t>::myStack(size_t size):
        data_ (new Data_t[size]),
        size_ (size),
        capacity_ (size)
	{
		CHECK(this->good(), "Unable to construct stack\n");
	}


	template <typename Data_t>
	myStack<Data_t>::myStack(const myStack<Data_t>& stack)
	{
    	CHECK(stack.ok(), "Origin stack is invalid\n");

    	data_     = new Data_t[stack.size_];
    	size_     = stack.size_;
    	capacity_ = stack.capacity_;

    	std::copy_n(stack.data_, size_, data_);

    	CHECK(this->good(), "Unable to construct stack\n");
	}


	myStack<Data_t>::myStack(myStack<Data_t>&& stack)
    {
        CHECK(stack.good(), "Unable to create stack from invalid origin\n");

        data_     = stack.data_;
        size_     = stack.size_;
        capacity_ = stack.capacity_;

        stack.data_ = nullptr;
        stack.size_ = 0U;

        CHECK(this->good(), "Unable to construct stack\n");

        CHECK(!stack.good(), "Origin was not destructed after move\n");
    }


    template <typename Data_t>
    myStack<Data_t>& myStack<Data_t>::operator=(const myStack<Data_t>& stack)
    {
        CHECK(this->good(), "Left operand of copy assignment is invalid\n");
        CHECK(stack.good(), "Right operand of copy assignment is invalid\n");

        // If left operand is a right operand at same time
        if (this == &stack) {return *this;}

        delete[] data_;

        data_     = new Data_t[stack.size_];
        size_     = stack.size_;
        capacity_ = stack.capacity_;

        std::copy_n(stack.data_, size_, data_);

        CHECK(this->good(), "Unable to copy stack\n");

        return *this;
    }


    template <typename Data_t>
    myStack<Data_t>& myStack<Data_t>::operator=(myStack<Data_t>&& stack)
    {
        CHECK(this->good(),
            "Left operand of move assignment is invalid\n");
        CHECK(stack.good(),
            "Right operand of move assignment is invalid\n");
        CHECK(this != &stack,
            "Move assignment from itself must not be generated by compiler. How?\n");

        delete[] data_;

        data_     = stack.data_;
        size_     = stack.size_;
        capacity_ = stack.capacity_;

        stack.data_ = nullptr;
        stack.size_ = 0U;
        stack.capacity_ = 0U;

        CHECK(this->good(), "Unable to perform move assignment\n");

        CHECK(!stack.good(), "Origin was not destructed after move\n");

        return *this;
    }

    template <typename Data_t>
    myStack<Data_t>::~myStack()
    {
        if (data_ != nullptr)
        {
            delete[] data_;
        }

        data_ = nullptr;
    }

    //------------------
    // Interface && other
    //------------------

    template <typename Data_t>
    size_t myStack<Data_t>::size() const
    {
        CHECK(this->good(), "Unable to perform move assignment\n");

        return size_;
    }

    template <typename Data_t>
    size_t myStack<Data_t>::capacity() const
    {
        CHECK(this->good(), "Unable to perform move assignment\n");

        return capacity_;
    }

    template <typename Data_t>
    myStack<Data_t>& myStack<Data_t>::resize(size_t size)
    {
        CHECK(this->good(), "Invalid stack\n");

        if (new_size == size_) {return *this;}

        Data_t* new_data = new Data_t[size];

        std::copy_n(new_data, std::min(size, size_), data_);

        delete[] data_;

        data_ = new_data;
        size_ = new_size;
        capacity_ = new_size;

        CHECK(this->good(), "Unable to resize\n");

        return *this;
    }

    template <typename Data_t>
    void myStack<Data_t>::push(const myStack<Data_t>& element)
    {
        CHECK(this->good(), "Invalid stack\n");

        if (new_size == size_) {return *this;}

        Data_t* new_data = new Data_t[size];

        std::copy_n(new_data, std::min(size, size_), data_);

        delete[] data_;

        data_ = new_data;
        size_ = new_size;
        capacity_ = new_size;

        CHECK(this->good(), "Unable to push element\n");

        return *this;
    }

} // namespace handMadeStack

/*
1)push back
2)pop back
*/